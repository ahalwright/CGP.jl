Preparing overleaf version of evolvability paper.  Evolvability TODO.

Created alternate overleaf account with email:  evolvability@fastemail.us running in Brave browser.
Identical to the version overleaf@ftml and successfully compiled.

TODOs:

Finish Introduction/Introduction

Describe random walk sampling in Methods/Sampling

Describe total evolvability in Methods/Total Evolvability

Rewrite paragraph in Exact/Approximate Evolvability in terms of redundancy instead of complexity

Perhaps move paragraph to Total Evolvabilty in Exact/Approximate Evolvability

Look carefully at commented-out subsection A mathematical definition of evolvability and entropy evolvability


Enumerating all 3x1 5 instructions phenotypes.

using BitSets
kdf = read_dataframe("../data/8_9_22/k_complexity_LGPsummary.csv")
f6 = findall(x->x==6,kdf.K_complexity)
bs = BitSet(f6)
@time for i = 1:200^3
         if output_values(circuit_int_to_circuit( i, p, funcs ))[1] in bs
           println("i: ",i,"  ov: ",output_values(circuit_int_to_circuit( i, p, funcs )))
         end
       end
27.504951 seconds
function testK6( p::Parameters, funcs::Vector{Func}, bs::BitSet )
  count = 0
  for i = 1:200^p.numinteriors
    if output_values(circuit_int_to_circuit( i, p, funcs ))[1] in bs
      #println("i: ",i,"  ov: ",output_values(circuit_int_to_circuit( i, p, funcs )))
      count += 1
    end
  end
  count
end
@time testK6( p, funcs, bs ) #  22.347597 seconds # 8064




surt2
using .Threads
p = Parameters(3,1,4,2); funcs=default_funcs(p)[1:4]
@time ph_list = [ Threads.Atomic{UInt8}(0) for i= 1:200^p.numinteriors]
154.682777 seconds
63.624156 seconds  #second try
@time Threads.@threads for i = 1:200^p.numinteriors
               Threads.atomic_add!( ph_list[i], output_values(circuit_int_to_circuit( Int128(i), p, funcs ))[1] )
             end
1850.696368 seconds

@time Threads.@threads for i = 1:200^p.numinteriors
               ph_list[i] = output_values(circuit_int_to_circuit( Int128(i), p, funcs ))[1] 
             end
