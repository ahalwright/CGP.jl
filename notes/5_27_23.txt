Redo log freq vs sampling evolvability and exact sampling evol for universal properties paper.

Maybe based on notes/10_9_22.txt

Created rwdf6 to rwdf14 as in ???

include("Robustness.jl")
nsteps = 5000
nwalks = 10000
numinputs=3; ngates=5; lb =3
p5 = Parameters(numinputs,1,ngates,lb)   # Same for p5, p6, p8, p10, p12, p14
# Each of the following steps takes 3 to 5 minutes multithreaded
@time rwdf5 = run_random_walks_parallel( p5, funcs, nwalks, collect(MyInt(0):MyInt(2^(2^p.numinputs)-1)), nsteps );
@time rwdf6 = run_random_walks_parallel( p6, funcs, nwalks, collect(MyInt(0):MyInt(2^(2^p.numinputs)-1)), nsteps );
@time rwdf8 = run_random_walks_parallel( p8, funcs, nwalks, collect(MyInt(0):MyInt(2^(2^p.numinputs)-1)), nsteps );
@time rwdf10 = run_random_walks_parallel( p10, funcs, nwalks, collect(MyInt(0):MyInt(2^(2^p.numinputs)-1)), nsteps );
@time rwdf12 = run_random_walks_parallel( p12, funcs, nwalks, collect(MyInt(0):MyInt(2^(2^p.numinputs)-1)), nsteps );
@time rwdf14 = run_random_walks_parallel( p14, funcs, nwalks, collect(MyInt(0):MyInt(2^(2^p.numinputs)-1)), nsteps );

p  # Parameters(1, 4, 0.05, 0.0, 3, 1, 2, 8, 4)
rdict = redundancy_dict(p,funcs);
lg_freq = map(ph->lg10(rdict[ph]), MyInt(0x0):MyInt(2^2^p.numinputs-1) );
insertcols!( rwdf8, 6, :lg_freq=>lg_freq );

p14 = Parameters(3,1,14,7)
Parameters(1, 4, 0.05, 0.0, 3, 1, 2, 14, 7)
rdict14 = redundancy_dict(p14,funcs);
csvfile: ../data/counts/count_outputs_ch_4funcs_3inputs_14gate_7lb_K.csv
lg_freq = map(ph->lg10(rdict14[ph]), MyInt(0x0):MyInt(2^2^p.numinputs-1) );
insertcols!( rwdf14, 6, :lg_freq=>lg_freq );
scatter(rwdf8.d_evolvability, rwdf8.lg_freq, smooth = true, labels="8 gates approxmate",legend=:topleft)
scatter!(  rwdf14.d_evolvability, rwdf14.lg_freq, smooth=true, labels="14 gates approxmate")
scatter!(fill(255,256),map(x->lg10(rdict[x]),0x0000:0x00ff),labels="exact evolvability")
plot!(xlabel = "degree evolvability", ylabel="log frequency")
savefig("../data/5_21_23/lg_freq_vs_degree_evol_exact_8_14gates.png")


Topics not in paper:

