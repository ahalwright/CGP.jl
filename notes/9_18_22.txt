How to create a real simple example for my definition of evolvability?
And also a plots of convergence of sample results to true evolvability.

Discovered that my multiset definition is essentially strength as defined in Hu (2020) normalized to
the redundancy of the phenotype.  So the normalization is what is different.

pheno_counts_ch() in Fnc.jl will create the entire GP map as a vector mapping circuit_ints to phenotypes.
Example:
p = Parameters(3,1,4,4); funcs=default_funcs(p)
@time (df,P) = pheno_counts_ch(p,funcs,output_vect=true) #  113 seconds on Mac.
length(P) #  9437185

p = Parameters(3,1,5,3); funcs=default_funcs(p)
Int64(ceil(count_circuits_ch( p, nfuncs=length(funcs))))  # 60466176
@time (df,P) = pheno_counts_ch(p,funcs,output_vect=true)  # 767 seconds
findall(x->x!=0,df.counts)  #  166-element Vector{Int64}

No pmap(), but parallelizable.  Calls output_values() for each circuit_int.

Can we compute exact evolvability for each phenotype?  Yes:  compute exact phenotype matrix as below.
Not parallelized---harder than first look.

data/run_phnet_matrixB.jl computes exact pheno network but takes a long time.
uses Parameters(3,1,4,3), length(funcs)=4.  Time:  1297 seconds
Parameters(3,1,5,3) is infeasible without parallelization

Potential results:  
  Simple example of evolvability definition.
  Plot convergence to true evolvability for rare and common goals.

=============================================
Testing hypothesis that higher K complexity means more iterations of neutral_evolution()

Uses run_geno_complexity() which is in Evolvability.jl

A run:
@time include("../data/9_18_22/run_geno_complexityC.jl")   # 1852 seconds # 3 slow to finish goals
